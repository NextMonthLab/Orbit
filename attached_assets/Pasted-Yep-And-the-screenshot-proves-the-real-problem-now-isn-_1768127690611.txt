Yep. And the screenshot proves the real problem now isn’t the background stepping anymore – it’s your manual truncation plus a couple of “anti-wrap” CSS choices that are forcing the headline to collapse and ellipsis.

Right now you’re literally doing this:
	•	Hard limit: 60 chars → truncatedHeadline
	•	And you’re also using:
	•	wordBreak: 'keep-all'
	•	overflowWrap: 'normal'
	•	hyphens: 'none'

So the browser can’t break where it wants, and then you chop the sentence anyway. Result: “favored over traditional se…”

Let’s fix it properly.

The goal
	•	Never character-truncate headlines
	•	Instead: wrap naturally inside a single panel
	•	But keep it within your “~1/3 screen” constraint using:
	•	maxWidth
	•	sensible fontScale
	•	and a max line count (2–3 lines) if you really need it

Fix 1: Remove manual truncation entirely

Delete this:

const truncatedHeadline = headline.length > 60
  ? headline.substring(0, 57) + '...'
  : headline;

…and render headline as-is.

Fix 2: Change your wrapping rules (these are currently fighting you)

Update baseContainerStyles to allow good wrapping:

const baseContainerStyles: React.CSSProperties = {
  display: 'inline-block',
  maxWidth: '92%',
  textAlign: 'center',
  whiteSpace: 'normal',
  wordBreak: 'normal',
  overflowWrap: 'anywhere', // key: prevents “stuck” wrapping
  hyphens: 'auto',          // optional but nice
};

Why this matters
	•	keep-all is great for CJK languages, but in English it often creates “can’t break where needed” behaviour.
	•	overflowWrap: anywhere is your safety net for awkward long words/URLs.

Fix 3: If you need limits, cap by lines not characters

This gives you the “pro” look without chopping meaning mid-sentence.

Add this to the <p> style when the panel is on:

const clampHeadline: React.CSSProperties = {
  display: '-webkit-box',
  WebkitBoxOrient: 'vertical',
  WebkitLineClamp: 3,  // 2 or 3 lines works best for 9x16
  overflow: 'hidden',
};

Then:

<p className="m-0" style={{ ...headlineStyles, ...clampHeadline }}>
  {headline}
</p>

That will end with an ellipsis only if it truly exceeds the line limit, and it’ll still look intentional.

Fix 4: Don’t override the panel padding twice

You’ve got padding in the token (panel case sets 20px 28px) then you overwrite it here:

style={{
  ...bgStyles,
  padding: background.treatment !== 'none' ? '14px 20px' : undefined,
}}

Pick one source of truth. I’d remove the override entirely and let the token own it:

style={bgStyles}

Fix 5: Your font scaling thresholds are too aggressive for headlines

You’re scaling based on headline + supporting. But the supporting is outside the panel and smaller. It shouldn’t punish the headline.

Change:

const textLength = headline.length + (supporting?.length || 0);

To:

const textLength = headline.length;

Then tweak thresholds:

const fontScale = textLength > 110 ? 0.75 : textLength > 80 ? 0.85 : 1;

That stops “normal” headlines being shrunk into oblivion.

⸻

Minimal patch (the exact changes I’d make)

1) Update baseContainerStyles

const baseContainerStyles: React.CSSProperties = {
  display: 'inline-block',
  maxWidth: '92%',
  textAlign: 'center',
  whiteSpace: 'normal',
  wordBreak: 'normal',
  overflowWrap: 'anywhere',
  hyphens: 'auto',
};

2) Remove truncation and render full headline

const clampHeadline: React.CSSProperties = {
  display: '-webkit-box',
  WebkitBoxOrient: 'vertical',
  WebkitLineClamp: 3,
  overflow: 'hidden',
};

...

<div style={bgStyles}>
  <p className="m-0" style={{ ...headlineStyles, ...clampHeadline }}>
    {headline}
  </p>
</div>

3) Scale only from headline length

const textLength = headline.length;
const fontScale = textLength > 110 ? 0.75 : textLength > 80 ? 0.85 : 1;


⸻

What you’ll see after this
	•	“favored over traditional search engines” will wrap cleanly in the panel.
	•	No weird “se…” truncation.
	•	The panel remains one cohesive box.
	•	If the headline is ridiculously long, it’ll clamp to 3 lines in a way that looks deliberate, not broken.

If you want, send me the backgroundTokens.panel definition as well – because if that token is also applying something like display: inline-flex or weird line-height constraints, we’ll clean that too.